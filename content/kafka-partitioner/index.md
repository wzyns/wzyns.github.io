---
title: "Kafka 파티셔너"
date: "2025-08-07 00:00:00"
---

사용자의 ID를 키값으로 지정해 카프카 메시지를 발행하고 있었는데, 같은 사용자에 대한 메시지가 서로 다른 파티션에 할당되는 것을 발견했다.
내 짧은 배경 지식으로는 메시지의 키값의 해시 기반으로 파티션을 정하기 때문에, 키값이 동일한 두 메시지는 반드시 같은 파티션에 할당되어야 했다.
원인을 찾는 중 카프카에서 사용하는 몇가지 파티셔너의 동작에 대해 알게 되었다.

## 카프카의 파티셔너

- 기본 파티셔너
- 라운드-로빈 파티셔너
- 유니폼 스티키 파티셔너
- 커스텀 파티셔너

## 기본 파티셔너

키값의 유무에 따라 동작이 나뉜다.

### 키값이 null인 경우

- 키값이 null인 레코드가 주어지면, 레코드는 현재 사용 가능한 토픽의 파티션 중 하나에 랜덤하게 저장된다.
- 파티션별로 균등하게 저장하기 위해 라운드 로빈 알고리즘이 사용된다.
- 카프카 2.4부터는 Sticky 처리가 추가되는데, 라운드 로빈을 할 때 레코드 하나마다 파티션이 바뀌는 것이 아니라 배치 단위로 바뀌는 것을 의미한다.

### 키값이 주어진 경우

이게 내가 원했던 동작이다.

- 키값이 지정된 상황에서 기본 파티셔너를 사용할 경우, 키값을 해시한 결과를 기준으로 파티션을 결정한다.
- 때문에 동일한 키값은 동일한 파티션에 저장된다.
- 바로 위 키값이 null인 케이스에서는 현재 사용 가능한 파티션만 대상으로 본다고 했지만, 이 케이스에서는 모든 파티션을 대상으로 하기 때문에 대상 파티션에 장애가 발생한 경우 에러가 발생한다. 생각해보면 당연한 동작인데, 파티션에 장애가 발생했다고 한들 키값이 동일한 메시지는 무조건 같은 파티션에 저장되어야 하기 때문이다.
- 하지만 중간에 파티션 개수가 변경된다면? 더 이상 보장이 불가능하다.

## 라운드-로빈 파티셔너

키값을 포함하고 있는 레코드라도 라운드 로빈을 통해 파티션이 결정된다.

## 커스텀 파티셔너를 구현할 수도 있다

(Java 기준) Partitioner 인터페이스를 구현해 커스텀 파티셔너를 만들 수도 있다. 구체적 예시는 내일의 나에게 미룸.

## Reference

- 그웬 샤피라의 카프카 핵심 가이드 2판에서 기본 개념을 익혔다.
- nifi를 사용하고 있어서 [nifi 문서](https://nifi.apache.org/components/org.apache.nifi.kafka.processors.PublishKafka/)도 확인했는데, Partitioner Class 옵션을 참고. 니가 원하는 것은 DefaultPartitioner다~ 라고 말해주고 있음.
